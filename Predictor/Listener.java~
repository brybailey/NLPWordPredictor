/*
 * 2016 Bryan Bailey & Braden Becker
 *
 *
 */

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.*;
import java.io.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JFrame;
import javax.swing.JTextField;

public class Listener implements KeyListener{
    //Textfields
    JTextField input;
    JTextField output;
    //Word level prediciton tables
    BigramPredictor bigramPredictor;
    TrigramPredictor trigramPredictor;
    QuadgramPredictor quadgramPredictor;
    
    int numberOfWords=0;
    int wordLength;
    int lastCode;
    int wordCount=0;
    String sentence="";
    String first="";
    String second="";
    String third="";
    String secondLastWord="";
    int lastSpaceIndex=0;
    String currentWord="";
    int level;
    
    PriorityQueue<Map.Entry<String,Integer>> pq;
    
    public Listener( JTextField input, JTextField output, int level ){
        super();
	this.level = level;
	if( level == 2 ) {
	    bigramPredictor = new BigramPredictor();
	} else if (level == 3 ) {
	    bigramPredictor = new BigramPredictor();
	    trigramPredictor = new TrigramPredictor();
	} else if (level == 4 ) {
	    bigramPredictor = new BigramPredictor();
	    trigramPredictor = new TrigramPredictor();
	    quadgramPredictor = new QuadgramPredictor();
	}
        this. input = input;
        this.output = output;
    }
    //Overwrite
    public void keyTyped(KeyEvent e) {
    }
    //Overwrite
    public void keyReleased(KeyEvent e) {
    }
    //Process updates
    public void keyPressed(KeyEvent e) {
        //KeyEvent code
        int code = e.getKeyCode();
        //Typed String
        String s = Character.toString(e.getKeyChar());
        //Current sentence
        sentence = input.getText();
        currentWord+=s;
        // System.out.println(code);
        System.out.println(s);
        //Spacebar pressed
        if(code == KeyEvent.VK_PERIOD){
            wordCount++;
            currentWord="";
            //Space pressed for the second time
            if(code == lastCode){
                input.setText(sentence+getFirstWord(output.getText()));
                sentence = input.getText();
                
            }
            System.out.println("WC: "+wordCount);
            
            //One word in sentence, use bigram model
            if(wordCount>0 && (wordCount<2||level==2) ){
                first = getLastWord(sentence);
		if( bigramPredictor.canPredict(first)) {
		    pq = bigramPredictor.predict(first);
		} else pq = null;

                //At least two words in sentence, use trigram model
            } else if(wordCount>1 && (wordCount<3||level==3)){
                first = getLastWord(sentence);
                sentence = removeLastWord(sentence);
                second = getLastWord(sentence);
		if( trigramPredictor.canPredict(second,first) ) {
		    pq = trigramPredictor.predict(second,first);
		} else if ( bigramPredictor.canPredict(first) ){
		    pq = bigramPredictor.predict(first);
		} else pq = null;

            }else if (wordCount>2 && (wordCount<4||level==4) ){
		first = getLastWord(sentence);
		sentence = removeLastWord(sentence);
		second = getLastWord(sentence);
		sentence = removeLastWord(sentence);
		third = getLastWord(sentence);
		if ( quadgramPredictor.canPredict(third,second,first ) ) {
		    pq = quadgramPredictor.predict(third,second,first);
		} else if( trigramPredictor.canPredict(second,first) ) {
		    pq = trigramPredictor.predict(second,first);
		} else if ( bigramPredictor.canPredict(first) ){
		    pq = bigramPredictor.predict(first);
		} else pq = null; 

	    } else {
                first = sentence;	
		pq = null;
            }
	    printTopResults(pq);
            //Delete
        } else if(code == KeyEvent.VK_BACK_SPACE){
            System.out.println("Back Space");
            
            //All normal alphanumerics
        } else if( wordCount > 0 ) {
            sentence += s;
            
            if( pq!= null ) {
		PriorityQueue<Map.Entry<String,Integer>> newpq = new PriorityQueue<Map.Entry<String,Integer>>(200000, new Comparator<Map.Entry<String, Integer>>() {
			public int compare( Map.Entry<String,Integer> arg0,
					    Map.Entry<String,Integer> arg1) {
			    return arg1.getValue().compareTo(arg0.getValue() );
			}
		    });
		
		//	    System.out.println( "CHECK FIRST: " + pq.peek() );
		for( Map.Entry<String,Integer> element: pq ) {
		    if( element.getKey().startsWith( currentWord ) ) {
			newpq.add( element );
		    }
		}
		pq = newpq;
		//	    System.out.println( " CHECK: " + pq.peek() );
		if(pq!=null &&pq.peek()!=null ){
		    //                output.setText( pq.peek().getKey() );
		    printTopResults( pq );
		    //                System.out.println(" WORD COUNT CHECK " );
		} else{
		    //  System.out.println("Failed to match word: " + currentWord);
		}
		
	    }
	}
	    lastCode = code;
    }
	
    public String getLastWord(String s){
        String w = s.substring(s.lastIndexOf(".")+1,s.length());
        return w;
    }

    public String getFirstWord(String s) {
	String first = s.substring(0, s.indexOf("\n"));
	return first;
    }
    public String removeLastWord(String s){
        String ns = s.substring(0,s.lastIndexOf("."));
        return ns;
    }
    public String removeTrailingSpace(String s){
        String ns=s.substring(s.lastIndexOf("."));
        return ns;
    }

    public void printTopResults( PriorityQueue<Map.Entry<String,Integer>> predictions ) {
	if( predictions != null ) {
	    PriorityQueue<Map.Entry<String,Integer>> temp = new PriorityQueue<Map.Entry<String,Integer>>(5, new Comparator<Map.Entry<String, Integer>>() {
		    public int compare( Map.Entry<String,Integer> arg0,
					Map.Entry<String,Integer> arg1) {
                    return arg1.getValue().compareTo(arg0.getValue() );
		    }
		});
	    String outputText = "";
	    for( int i=0; i<predictions.size()&&i<5; i++ ) {
		outputText += predictions.peek().getKey()+"\n";
		temp.add(predictions.poll());
	    }
	    for( Map.Entry<String,Integer> reverse: temp ) {
		predictions.add( reverse );
	    }
	    //	System.out.println( predictions.peek() + " AND " + temp.peek() );
	    output.setText(outputText);
	} else {
	    output.setText( "Wow! Cool new word dude!" );
	}
	
    }
}































